
    // Check if color scheme is set up yet
    if (!color) {
        color = d3.scale.category20();
    }

    // Check if pie object is set up yet
    if (!pie) {
        pie = d3.layout.pie()
            .value(archLengthAccessor) // Tell the pie chart how to extract the arch length value from a data row
            .sort(null);
    }
  
    var radius = Math.min(width, height) / 2;

    var arc = d3.svg.arc()
        .innerRadius(radius - 100)
        .outerRadius(radius - 20);

    if (!svg) {
        var g = d3.select("#js_chart").append("svg") // Append the svg object and center it on the div
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

        svg = d3.select("svg");
    }

    if (!path) {
        var g = svg.select("g");
        //
        // Add arc slices to enable per arch labels
        //
        var arcs = g.selectAll("g.slice") // This selects all <g> elements with class slice (there aren't any yet)
            .data(pie(chartdata))            // Associate the generated pie data (an array of arcs, each having startAngle, endAngle and value properties)
            .enter()                      // This will create <g> elements for every "extra" data element that should be associated with a selection. The result is creating a <g> for every object in the data array
            .append("svg:g")              // Create a group to hold each slice (we will have a <path> and a <text> element associated with each slice)
            .attr("class", "slice");      // Allow us to style things in the slices (like text)
        
        path = arcs; // Arcs collection

        arcs.append("svg:path") // create the arcs based on the pie data
            .attr("fill", function (d, i) { return color(i); }) // Set the color for each slice to be chosen from the color function defined above
            .attr("d", arc) // This creates the actual SVG path using the associated data (pie) with the arc drawing function
            .attr("opacity", function (d, i) { //Spotfire 5.5 style fading marking coloring
                if (markedRows != chartdata.length && !chartdata[i].hints.marked && markedRows != 0) {
                    return (0.3);
                }
                else {
                    return (1);
                }
            })
            .attr("id", function (d, i) { return (chartdata[i].hints.index); }) // store the index as id for use in marking logic
            .on("mousedown", function () { return; })
            .each(function (d) { this._current = d; });   // store the initial values 

        arcs.append("svg:text") //add a label to each slice
            .attr("transform", function (d) { //set the label's origin to the center of the arc
                // we have to make sure to set these before calling arc.centroid
                d.innerRadius = (radius - 100);
                d.outerRadius = (radius - 20);
                return "translate(" + arc.centroid(d) + ")"; 
            })
            .attr("text-anchor", "middle") 
            .attr("pointer-events", "none")
            .text(function (d, i) {
                return chartdata[i].items[1];  // link back to chartdata for labels
            }); 
    }
    else {
        // If we already have generated the above objects, reshape them as nessecary as required with the renewed data object
        var g = svg.select("g")
            .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

        var arcs = g.selectAll("g.slice");
        arcs.remove();

        arcs = g.selectAll("g.slice") 
            .data(pie(chartdata)) 
            .enter() 
            .append("svg:g") 
            .attr("class", "slice"); 

        arcs.append("svg:path")
            .attr("fill", function (d, i) { return color(i); }) 
            .attr("d", arc) 
            .attr("opacity", function (d, i) {
                if (markedRows != chartdata.length && !chartdata[i].hints.marked && markedRows != 0) {
                    return (0.3);
                }
                else {
                    return (1);
                }
            })
            .attr("id", function (d, i) { return (chartdata[i].hints.index); })
            .on("mousedown", function () { return; })
            .each(function (d) { this._current = d; });   // Store the initial values   

        arcs.append("svg:text") // Add a label to each slice
            .attr("transform", function (d) { // Set the label's origin to the center of the arc
                d.innerRadius = (radius - 100);
                d.outerRadius = (radius - 20);
                return "translate(" + arc.centroid(d) + ")"; // This gives us a pair of coordinates like [50, 50]
            })
            .attr("text-anchor", "middle") //center the text on it's origin
            .attr("pointer-events", "none")
            .text(function (d, i) {
                    return chartdata[i].items[1]; 
            }); // Get the label from our original data array
    }
